<p>﻿</p><p><span style="font-size: 12px;">﻿</span><span style="font-size: 36px; letter-spacing: 0.1px;">﻿JS</span></p><p><span style="font-size: 12px;">﻿/ - komentowanie 1 linii /* blabla */ komentowanie wielu linii</span></p><p><span style="font-size: 12px;">nazwy zmiennych jak w pascalu&nbsp; &nbsp;myNewVariable</span></p><p><span style="font-size: 12px;"><b>hoisting</b> - JS przenosi wszystkie deklaracje zmiennych var na górę kodu ale nie inicjalizacje np. var x przeniesie ale var x = 7 juz nie</span></p><p><span style="font-size: 12px;"><b>var</b>&nbsp; s&nbsp; - zmienna s działająca w zakresie funkcji</span></p><p><span style="font-size: 12px;"><b>let</b>&nbsp;s -&nbsp; zmienna s działająca w zakresie bloku</span></p><p><span style="font-size: 12px;"><b>const</b> s - read-only stała, nazywanie: WSZYSTKIE_DUŻE_ODDZIELONE_PODŁOGĄ</span></p><p><span style="font-size: 12px;">s - globalna zmienna s</span></p><p><span style="font-size: 12px;"><b>Infinity</b></span></p><p><span style="font-size: 12px;"><b>"use strict"</b></span></p><p><span style="font-size: 12px;">increment: i++/ i = i + 1/i+=1/i+=5;</span></p><p><span style="font-size: 12px;">decrement: i--/i = i - 1;</span></p><p><span style="font-size: 12px;">+=5 -=5 *=5 /=5</span></p><p><span style="font-size: 12px;">** potęga</span></p><p><span style="font-size: 12px;">remainder: %;</span></p><p><span style="font-size: 12px;">Math.floor(5/2) = 2 - dwa pełne;</span></p><p><span style="font-size: 12px;">Math.pow(liczba,do potęgi której)</span></p><p><span style="font-size: 12px;">console.log(co chcemy zeby pojawiło się&nbsp; w konsoli)</span></p><p><span style="font-size: 12px;"><b>single line multi declaration</b>: var i = 4,j = 5, k = 7;</span></p><p><span style="font-size: 12px;">metody na numerach:</span></p><ul><li><span style="font-size: 12px;">num.toString()</span></li><li><span style="font-size: 12px;">num.toFixed(ilość_miejsc_po_przecinku)</span></li><li><span style="font-size: 12px;">num.toPrecision(do którego zaokrąglić miejsca)</span></li><li><span style="font-size: 12px;">num.toExponential() &lt;--- notacja wykładnicza</span></li><li><span style="font-size: 12px;"><b>Math.round(num) &lt;---- zaokrąglenie do całkowitej</b></span></li><li><span style="font-size: 12px;">Number.MAX_VALUE, MIN_VALUE, POSITIVE_INFINITY, NEGATIVE_INFINITY,</span></li></ul><p><span style="font-size: 18px;">﻿STRINGI</span><span style="font-size: 12px;">﻿</span></p><p><span style="font-size: 12px;">\ &lt;- dzieki temu <b>ucieka sie od znaków specjalnych</b> w js</span></p><p><span style="font-size: 12px;">'"quote"' ====&gt; "quote</span><span style="font-size: 12px; letter-spacing: 0.1px;">"</span></p><p><span style="font-size: 12px; letter-spacing: 0.1px;"><b>typeof</b> "s" // returns "string"</span></p><p><span style="font-size: 12px;">escape sequences:</span></p><ul><li><span style="font-size: 12px;">\n</span></li><li><span style="font-size: 12px;">\\ - backslash</span></li><li><span style="font-size: 12px;">\" \'</span></li><li><span style="font-size: 12px;">\r - jakas karetka</span></li><li><span style="font-size: 12px;">\t - tab</span></li><li><span style="font-size: 12px;">\b - backspace</span></li><li><span style="font-size: 12px;">\f - jakis formulaż</span></li><li><span style="font-size: 12px;">"line breakup \</span></li><li><span style="font-size: 12px;">w ten sposób "&nbsp;</span></li></ul><p><b>dodawanie stringów</b> "Jestem " + "chujem"; var i = "Jestem "; i+="chujem";</p><p>"masz " + temperature + " stopni gorączki";</p><p>stringlosowy<b>.length</b>; &lt;--- jako atrybut a nie funkcja;</p><p>stringlosowy[0] &lt;--- <b>pierwszy element danej</b>;</p><p><b>strings are immutable</b> - nie da sie zmienic wartosci stringa np.&nbsp; x = "Bob"; x[0] = "J" nie zmieni literki tylko wywali errora, da się jedynie tak x = "Job";</p><p><span style="font-size: 12px;"><b>ostatnia literka</b> stringlosowy[stringlosowy.length - 1]</span></p><p><span style="font-size: 12px;"><b>template literals</b>: trochę jak f"{nazwa zmiennej}" w pythonie, 'mam na imię ${nazwa zmiennej}'&nbsp; !!Uwaga kod używa ``` a nie ' ani "</span></p><p><b style="font-size: 12px; letter-spacing: 0.1px;">str.toUpperCase() | str.toLowerCase()</b></p><p><b style="font-size: 12px; letter-spacing: 0.1px;">stringi jak i każde inne typy danych mogą być objektami wystarczy let hi = new String('hi');</b></p><p><span style="font-size: 12px; letter-spacing: 0.1px;">str.search(keyword) &lt;--- pierwszy index szukanego keyworda &lt;--- może wziąć regex</span></p><p><span style="font-size: 12px; letter-spacing: 0.1px;">str.lastIndexOf(keyword) &lt;--- ostatni index szukanego keyworda&nbsp;&nbsp;</span></p><p><span style="font-size: 12px; letter-spacing: 0.1px;">str.trim() &lt;--- usuwa whitespace z obu stron stringa<br>String.fromCharCode(liczba reprezentująca dany znak) &lt;---- zwraca znak alfabetu lub symbol reprezentowany przez daną liczbę w danym kodowaniu znaków</span></p><p><span style="font-size: 12px; letter-spacing: 0.1px;">str.charCodeAt(index)</span><br></p><p><span style="font-size: 18px;">﻿ARRAYE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span></p><p><span style="font-size: 11px;">﻿</span><span style="font-size: 12px;">﻿<b>tworzenie</b>: var array = [1,2,3</span><span style="font-size: 12px; letter-spacing: 0.1px;">]</span></p><p><span style="font-size: 12px; letter-spacing: 0.1px;">wielowymiarowy array: [[2,1],[1,2]]</span></p><p><span style="font-size: 12px; letter-spacing: 0.1px;">index tez od 0</span></p><p><span style="font-size: 12px; letter-spacing: 0.1px;"><b>arrays are mutable</b>: var data = [1,2,3]; data[0] = 4; =&gt;&gt; data = [4,2,3]</span></p><p><span style="font-size: 12px; letter-spacing: 0.1px;">indexowanie wielowymiarowych tablic [0][0]</span></p><p><span style="font-size: 12px; letter-spacing: 0.1px;">dodawanie i usuwanie elementów:</span></p><ul><li><span style="font-size: 12px; letter-spacing: 0.1px;">dodawanie do tablic na koniec: arr.push(element</span><span style="font-size: 12px; letter-spacing: 0.1px;">)</span></li><li><span style="font-size: 12px; letter-spacing: 0.1px;">usuwanie od tablic z końca: arr.pop()&nbsp; &nbsp;x = arr.pop()</span></li><li><span style="font-size: 12px; letter-spacing: 0.1px;">usuwanie z początku: arr.shift()</span></li><li><span style="font-size: 12px;">dodawanie na początku: arr.unshift(element)</span></li></ul><p><span style="font-size: 12px;"><b>spreadowanie</b> - rozkładanie arraya: ...arr&nbsp; &nbsp;np. gdy arr = [1,2] a funkcja przyjmuje pojedyńcze argumenty ale nie tabelę np. sum[1,2] to to samo co sum[...arr] ale nie sum[arr]</span></p><p><span style="font-size: 12px;"><b>tablice zadeklarowane const są mutable</b></span></p><p><b style="font-size: 12px; letter-spacing: 0.1px;">aby przeszkodzić danym w mutacji </b><span style="font-size: 12px; letter-spacing: 0.1px;">można wykorzystać funkcję Object.freeze(nazwa_obiektu)</span><span style="font-size: 12px;"><br></span></p><p><span style="font-size: 12px;"><b>arr1.concat(arr2) - </b>concatinate - scalenie tabel</span></p><p><span style="font-size: 12px;"><b>arr.splice(</b>index tabeli od którego zacząć usuwanie, ile elementów usunąć wliczając początkowy<b>) </b>jak pop i shift można przypisać usuwane elementy do zmiennej</span></p><p>splice(argument1,arg2, element, <b>którym zastąpić</b> )</p><p><b>arr.slice</b>(index na którym zacząć ekstrakc&nbsp;&nbsp;&nbsp;&nbsp;ję including, index, na którym skończyć ekstrakcję non including)&nbsp;- kopiuje dany wycinek arraya <b>&lt;i1,i2)</b></p><p><b>arr.indexOf(arg) </b>- bierze obiekt, który ma zostać znaleziony w tablicy i zwraca jego index lub <b>-1 jeśli obiekt nie istnieje, </b>funkcja nie jest globalna<b>&nbsp;&nbsp;</b></p><p><b>usunięcie pustych elementów z arraya </b>(np.usuniętych delete) <b>- array.filter(Boolean) </b>/<b>&nbsp;</b>array.filter((a)=&gt; a!="")</p><p><b>sortowanie:</b>&nbsp; arr.sort(func())&nbsp; &nbsp;<b> arr.sort((a,b) =&gt; a-b)</b></p><p><b>Array.isArray()</b></p><p>array.reverse(); array.sort()</p><p><b>compare function</b> &lt;--- sort(function) działa tak że wysyła argumenty do funkcji compare, która mówi: jeżeli a - b &lt; 0, to b będzie się znajdować przed a</p><p><b>sortowanie obiektów sort((a,b)=&gt; a.atrybut - b.atrybut)</b></p><p><span style="font-size: 18px;">﻿FUNKCJE</span></p><p><span style="font-size: 11px;">﻿</span><span style="font-size: 12px;"><b>﻿tworzenie:</b> function functionName() {console.log("chuj");}</span></p><p><span style="font-size: 12px;">argumenty zwyczajnie jak zwykle</span></p><p><span style="font-size: 12px;"><b>scope</b>:&nbsp;</span></p><ul><li><span style="font-size: 12px;">bez var to od razu globale</span></li><li><span style="font-size: 12px;">var to lokalne</span></li><li>var w funkcji sięga tylko funkcji</li><li><span style="font-size: 12px;">﻿bez var sięga całego kodu</span></li><li><span style="font-size: 12px;">local &gt; global jesli są takie same nazwy</span></li><li><span style="font-size: 12px;">let sięga tylko bloku</span></li></ul><p>return - wiadomo co i jak</p><p>jak nie ma returna to return value = undefined</p><p><span style="font-size: 12px;">﻿varname = sum(2,3) jezeli sum ma return a+b</span></p><p><span style="font-size: 12px;"><b>arrow functions:</b></span></p><ul><li><span style="font-size: 12px;">tworzenie: const myFunc = (argument) =&gt; {blabla}</span></li><li><span style="font-size: 12px;">tworzenie 2: const myFunc = () =&gt;&nbsp; return_statement</span></li><li><span style="font-size: 12px;">np. const myFunc = () =&gt; "siedem"</span></li><li><span style="font-size: 12px;">jeśli chcemy <b>zwrócić obiekt</b> o własnościach xyz mających wartość xyz, to&nbsp; zamiast (x,y,z)=&gt;({x:x,y:y,z:z}) można zrobić (x,y,z)=&gt;<b>({x,y,z})</b></span></li></ul><p><b>higher order functions:</b></p><ul><li>map: array.map(funkcja, którą wykonać na każdym elemencie z tabeli) np. array.map((array_element) =&gt; array_element * 2)</li><li>filter: array.filter(funkcja, przez którą przefiltrować każdy element tabeli) np. array.filter((arr_el) =&gt; arr_el &gt; 0 || arr_el &amp;2 == 0)</li><li>reduce</li><li>sort&nbsp; &nbsp;<b>uwaga lepiej użyć arr.concat([]).sort()</b></li><li>every</li></ul><p>default parameters for arguments: function(name = "świnks")</p><p><b>func.call()</b> --&gt; odpalenie treści funkcji w innym miejscu</p><p><b>nieskończoność parametrów:</b></p><ul><li>zapis: function(...nazwa_tabeli_pod_jaką_będzie_dostęp_do_argumentów)</li></ul><p><b>funkcje w obiektach:</b></p><ul><li>ES5 -----&gt; funkcjawobj: function(){ co robi funkcja}</li><li>ES6 -----&gt; funkcjawobj() {co robi funkcja}</li></ul><p><b>immediately invoked function expression IIFE: (function(){blablabla})()&nbsp; &nbsp;(function(arg){blablabla})(arg)</b></p><p><b>label: {statements},</b></p><p><b>break label; </b>&lt;-- breaks out of entire loop</p><p><b>continue label; </b>&lt;-- breaks out of single iteration of a loop</p><p><b>try</b> {block of code to try} <b>catch(err){</b>console.log(err.message/ err.name)} <b>finally&nbsp;</b>{what to execute anyways} &lt;--JS wywalając error tworzy obiekt Error z propertiami name i message&nbsp;</p><p><b>throw</b> error_jakis_jaki_chcesz</p><p><b>callbacks </b>- funkcje przepuszczone do innych funkcji</p><p>first class function - zwykłe funkcje</p><p>higher order function - funkcje przyjmujące za argument inne funkcje</p><p>lambda - funkcje zwracane lub przepuszczane jako argumenty do innych funkcji</p><p>dzięki<b> return this</b>; w funkcji można od razu chainować np. funkcja s ma return this, więc np. funkcja d:&nbsp; &nbsp;obj.s().d()</p><p>avoid external dependence</p><p>filter &lt;--- najpierw odfiltrowuje dane a potem map &lt;---- zwraca określone części danych</p><p><b>usuwanie indexow z arraya za pomocą slice: zamiast splice(3) użyć m</b>&nbsp;&nbsp;&nbsp;&nbsp;<b>ożna slice(0,3)</b></p><p><b>używanie concat zamiast push</b></p><p><b>problem z sortem: </b>sort jest funkcją mutującą oryginalny array jednak da się tego uniknąć concatując pustą tabelę do tabeli którą sortujemy&nbsp;<span style="background-color: rgb(255, 255, 254); font-family: Ubuntu; font-size: 12px; white-space: pre; letter-spacing: 0.1px;">arr.concat([]).sort((a,b) =&gt; a-b);</span></p><p><b>arr.every(test function) </b>&lt;--- czy każdy element tabeli sprosta kryteriom zamieszczonym w test function, coś jak filter tylko że zamiast zwracać tabeli zwraca prawda lub fałsz</p><p><b>some </b>&lt;--- podobnie jak every ale to sprawdza czy jakikolwiek element tabeli sprosta kryteriom</p><p>currying i partial application:</p><ul><li><b>currying:</b></li><li>funkcja zwraca funkcję</li><li>wtedy możliwe jest functionName1(2)(3) gdzie 3 jest argumentem zwróconej już funkcji</li><li>możliwe jest też let kolejnyArgument&nbsp; = functionName1(2); kolejnyArgument(3) &lt;--- w tym momencie 3 jest argumentem funkcji zwróconej przez funkcję functionName1</li><li><b>partial application:</b></li><li>funkcja nie zwraca funkcji tylko jakiś statement</li><li>nazwaFunkcjiNiePartial zwraca x+y+z</li><li>let funkcjaPartial = nazwaFunkcjiNiePartial.<b>bind</b>(this,2,3)</li><li>funkcjaPartial(10) zwraca 13 bo pod this podstawia się 10</li></ul><p><span style="font-size: 18px;">﻿LOGICZNE</span></p><p><span style="font-size: 11px;"><b>if</b>:</span></p><ul><li><span style="font-size: 11px;">operatory porównania: </span></li><ul><li><span style="font-size: 11px;">== (3 == "3" //true), === (3 ==="3"//false)</span></li><li><span style="font-size: 11px;">&gt;= , &lt;=</span></li><li><span style="font-size: 11px;">﻿</span><span style="font-size: 12px;">﻿!=, !==&nbsp;</span></li><li><span style="font-size: 12px;">&gt;, &lt;</span></li><li><span style="font-size: 12px;">~ -negacja</span></li></ul><li>and: &amp;&amp;</li><li>or: ||</li><li>else</li><li>else if</li></ul><p><b>switch</b>:</p><ul><li>break; - moment stopu switcha</li><li>switch(numer casea)</li><li>case x: return valuex</li><li>case domyślny - default: return valuedefault</li><li>multiple same options- case 1: case 2: case 3: result = "1 2 or 3"</li></ul><p><b>ternary:</b></p><ul><li>condition ? statement-if-true : statement-if-false;</li><li>condition ? statement-if-true : condition-if-false ? statement-if-true : statement-if-false</li></ul><p><span style="font-size: 18px;">OBIEKTY:</span></p><p><span style="font-size: 12px;">﻿nazwaobiektu {costam: wartosc, cos2: wartosc2};</span></p><p><span style="font-size: 12px;">object.property</span></p><p><span style="font-size: 12px;">object.method()</span></p><p><span style="font-size: 12px;"><b>nazwaobiektu.costam</b> // = wartosc</span></p><p><span style="font-size: 12px;">nazwaobiektu['costam'] // = wartosc</span></p><p><span style="font-size: 12px;">nazwaobiektu[nazwazmiennej równej costam] // = wartosc</span></p><p><span style="font-size: 12px;">nazwaobiektu.cos3 = wartosc3; // = <b>dodawanie</b></span></p><p><span style="font-size: 12px;">delete nazwaobiektu.costam; // = <b>usuwanie</b><br></span><span style="font-size: 12px;">﻿nazwaobiektu.<b>hasOwnProperty</b>(costam) // = true nazwaobiektu.hasOwnProperty(cosnietam) // = false</span></p><p><span style="font-size: 12px;">costam in nazwaobiektu // =true</span></p><p><span style="font-size: 12px;">﻿json: {n:x,z:y}</span></p><p><span style="font-size: 12px;">nested objekty: nazwaobiektu.atrybut.atrybutwatrybucie / nazwaobiektu[atrybut].atrybutwatrybucie;</span></p><p><span style="font-size: 12px;"><b>destructuring assignment</b>:</span></p><ul><li><span style="font-size: 12px;">normalnie napisałoby się:</span></li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var obj = {x: 1, y: 2, z: 3}&nbsp; var x = obj.x, var y = obj.y, var z = obj.z</p><ul><li>a z destructuring assignment tak:</li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const {x, y, z} = obj&nbsp; &nbsp; lub gdy chcemy w innej kolejności -&nbsp; const {x: a, y: b, z: c}&nbsp; &nbsp; &nbsp; &nbsp;</p><ul><li><b>znestowane</b>: var obj = {a:{x:5,y:3},b:{x:5,y:3}} const {a:{x:varax,y:varay},b:{x:varbx,y:varby}} = obj&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</li><li>destructructuring assignment<b> działa również z arrayami</b>: arr = <b>[</b>3,4,5,6<b>]</b>; const [a,b] = arr // a = 3, b = 4</li><li>aby osiągnąć chciany index możemy używać przecinków np. const[,,,a] = arr// a&nbsp; = 4</li><li>const powoduje, że ta operacja jest lokalna, więc const [a,b] = [b,a] zamieni wartości lokalnie, a [a,b] = [b, a] globalnie</li><li>można użyć równiesz spread np. [a,b, ...restofthearray] = arr</li><li>używanie w funkcji, function destr({a,b}) =&gt; robienie czegos; destr[arr];</li></ul><p>dzięki składni <b>for in</b> można przelecieć przez wszystkie atrybuty obiektu i je wykorzystać np. for(name in names) {console.log(`my name is ${name}`)}</p><p><b>constructor objektu:</b></p><ul><li>nazywany z <b>dużej</b> litery</li><li>nie zwraca wartości&nbsp;</li><li>stosuje keyword this.property</li><li>przykład: function Dog(){this.legsNum = 6;&nbsp; }</li><li>użycie constructora do stworzenia obiektu: let blueBird = new Bird(); // bez new this. nie wskazywaloby obiektu</li><li><b>instanceof</b> - zwraca boolean czy obiekt został stworzony przy pomocy konkretnego konstruktora np. blueBird instanceof Bird&nbsp;</li><li>Obj.<b>prototype.isPrototypeOf</b>(obj)&lt;-- Obj - constructor, sprawdzamy czy dany obj dziedziczy prototype po Obj</li></ul><p><b>UWAGA for in nie zwraca normalnie obiektu tylko string -_____-</b></p><p>Object.keys(obj) &lt;---- zwraca tabelę z <b>atrybutami WŁASNYMI obiektu</b> z pierwszego poziomu</p><p>constructor.prototype.property&nbsp; = x; &lt;--- dzięki prototype wszystkie obiekty dzielą jedną zmienną, a nie mają tysiące duplikatów tej samej property</p><p><b>property:</b></p><ul><li>own property - osobista unikalna własność danego obiektu</li><li>prototype property - własność wszystkich instancji danego constructora naraz&nbsp;</li><li>hasOwnProperty() - <b>działa tylko na own property</b>, a prototype property się do nich nie zalicza&nbsp;&nbsp;&nbsp;&nbsp;</li><li>object.constructor - constructor property, <b>zwraca constructor function</b> na podstawie którego dany obiekt został stworzony</li><li>dodawanie <b>prototype properties usprawnione</b>: Object.prototype = {prototypeProperty1: "abc", } &lt;--- w zasadzie <b>tworzymy obiekt ze zmiennymi prot</b></li><li><b>uwaga</b> trzeba pamiętać o tym aby <b>do obiektu ze zmiennymi prototypowymi dodać constructor </b>inaczej we wszystkich instancjach obiektu nie bedzie dzialac metoda obj.constructor, mozna to zrobic tak-- Object.prototype = {<b>constructor: Nazwaconstructora</b>}</li></ul><p>prototype chain: <b>Object.prototype</b> &lt;=== Constructor.prototype &lt;=== object.prototype;&nbsp; &nbsp; &nbsp;<b>supertype &lt;=== subtype&nbsp;</b></p><p>Object.prototype - prototyp wszystkich obiektów</p><p><b>inheritance:</b>&nbsp;</p><ul><li>po pierwsze<b> stworzyć instance supertype'a</b> np. let animal = new Animal(); ale ma to parę minusów</li><li>inny sposób na stworzenie instancji supertype'a szczególnie pod inheritance: <b>let animal =</b> <b>Object.create(Animal.prototype )</b></li><li><b>INHERITANCE: Dog.prototype = Object.create(Animal.prototype);</b></li><li><b>po udanym inheritance należy zresetować constructor obiektu który inheritował, to znaczy przywrócić constructor do normy</b></li><li><b>Dog.prototype.constructor = Dog; a nie Animal</b></li><li><b>Supertype.call(this,zmiennaA,zmiennaB,itd) </b>- wpisując do konstruktora Subtype od razu odpala się content funkcji Supertype() &lt;--- dzięki temu inheritujemy properties zawarte w supertype constructorze;</li><li><b>Supertype.call(this)</b> &lt;-- inherituje properties, których wartości nie definiują zmienne</li></ul><p>PODSUMOWANIE INHERITANCE, CONSTRUCTOR i PROPERTY:</p><ul><li>&nbsp; &nbsp;inherit z <b>prototype</b>: sub.prototype = Object.create(super.prototype);</li><li>&nbsp; &nbsp;inherit z <b>constructora</b>:&nbsp; super.call(this)/ super.call(this,a,b,c,d); <b>sub.prototype.constructor = sub;</b></li><li>&nbsp; &nbsp;w prototype najlepiej trzymać el. wspólne i funkcje</li><li>&nbsp; &nbsp;w constructorze najlepiej trzymać unikatowe elementy</li><li>&nbsp;&nbsp;&nbsp;&nbsp;obj.<b>hasOwnProperty</b>(prop)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;obj.prototype.<b>isPrototypeOf</b>(anotherobj)</li><li>&nbsp; &nbsp; obj.<b>constructor</b></li></ul><p><b>mixin</b>: funkcja przyjmująca jako argument objekt i dająca mu jakąś funkcję np. function flyMixin(obj) { /tu nastepuje definicja/obj.fly&nbsp; = () =&gt; "Flying whoosh" };</p><p><b>prywatne properties w JS</b>: zmienne w funkcji constructora --&gt; ich widoczność ograniczona jest do zakresu funkcji np. let password; taką wartość można jedynie wydobyć funkcją danego obiektu(<b>privileged method</b>)</p><p>tworzeniu modułu przy pomocy IIFE</p><p><span style="font-size: 18px;">﻿KLASY:</span></p><p><span style="font-size: 12px;">﻿Klasy w ES5:&nbsp;</span></p><p>&nbsp; &nbsp; var SpaceShuttle = function(targetPlanet) {this.targetPlanet = targetPlanet;} ;// tworzenie constructora</p><p>&nbsp; &nbsp;<b> shuttle1 = new SpaceShuttle("Mars");</b></p><p>Klasy w <b>ECMAScript</b>:</p><p>&nbsp; &nbsp; &nbsp;class SpaceShuttle {&nbsp;<b>&nbsp;</b><span style="letter-spacing: 0.1px;"><b>constructor</b>(targetPlanet){</span><span style="letter-spacing: 0.1px;">this.targetPlanet = targetPlanet;</span><span style="letter-spacing: 0.1px;">}&nbsp;&nbsp;</span><span style="letter-spacing: 0.1px;">};</span></p><p><span style="letter-spacing: 0.1px;">shuttle2 -<b> new</b> SpaceShuttle("Jupiter");</span></p><p><span style="letter-spacing: 0.1px;">static:&nbsp; &nbsp;static methody nie trafiają do prototype tylko do samej w sobie klasy, więc użyć ich się da tylko Nazwaklasy.staticmethod();&nbsp; &nbsp; &nbsp;static hello();</span></p><p><span style="letter-spacing: 0.1px;"><b>getter -</b> funkcja zwracająca wartość atrybutu obiektu bez bezpośredniego odnoszenia się do niego np.</span></p><p>&nbsp; &nbsp; this.name = name&nbsp; &nbsp; &nbsp;<b>get</b> nickname(){return this.name};&nbsp; &nbsp; objname.nickname</p><p><b>setter</b> - funkcja ustawiająca wartość atrybutu obiektu bez bezpośredniego odnoszenia się do niego np.</p><p>&nbsp; &nbsp; this.name = name <b>set</b> nickname(nick)(this.name = nick) objname.nickname = "Dirk"</p><p>inheritance - class Dog <b>extends</b> Animal &lt;---- inherituje z klasy Animal</p><p><b>super</b>.funkcja_parenta() - super to obiekt, dzięki któremu możemy korzystać z funkcji parenta</p><p><span style="font-size: 18px; letter-spacing: 0.1px;">﻿PĘTLE:</span><br></p><p><span style="font-size: 11px;">﻿</span><span style="font-size: 12px;">﻿while(warunek)</span></p><p><span style="font-size: 12px;">do {pierw rób rzecz} while (warunek do sprawdzenia po wykonaniu rzeczy)</span></p><p>for(inicjacja;warunek;final-statement)</p><p><span style="letter-spacing: 0.1px;">final-statement np. i++; i+=2; itp.</span></p><p><span style="letter-spacing: 0.1px;"><b>iterate through content of array:</b></span></p><ul><li>for(i = 0; i&lt; myArray.length; i++) { console.log(myArray[i])}</li><li>for(i in myArray) {console.log(myArray[i])}</li><li>for(i = 0; i &lt; myArray.length; i++) {for(j = 0; j &lt; mylArray[i].length); j++ {console.log(myArray[i][j])}}&nbsp;</li></ul><p><span style="font-size: 18px;">﻿MATH</span></p><p><span style="font-size: 12px;">﻿Math.random(): zwraca losowy numer ze zbioru &lt;0,1)</span><span style="font-size: 18px;"><br></span>Math.floor(): zaokrąglanie do całkowitych</p><p>Math.max(a,b,c,d) / Math.max.apply(null,array) /<b>Math.max(...array)</b></p><p>Math.min()</p><p><span style="letter-spacing: 0.1px;">Aby otrzymać losową liczbę całkowitą: Math.floor(Math.random() * 10) gdzie 10 to górna granica zbioru prawostronnie otwartego<br></span><b>Aby otrzymać losową całkowitą w przedziale obustronnie domkniętym</b>: Math.floor(Math.random() * (max-min + 1)) + min&nbsp; &nbsp;dzieki temu dostajemy l. z przed. &lt;min, max&gt;&nbsp;</p><p><br></p><p><span style="font-size: 18px;">PARSOWANIE</span></p><p><span style="font-size: 12px;">﻿<b>parseInt(string)</b></span></p><p><span style="font-size: 12px;"><b>Number(any_type_of_data)</b></span></p><p><span style="font-size: 12px;"><b>parseFloat(float)</b></span></p><p><span style="font-size: 12px;"><b>toString(number)</b></span></p><p><span style="font-size: 12px;"><b>Boolean()</b></span></p><p><span style="font-size: 12px;"><b>String()</b></span></p><p><span style="font-size: 12px;">parseInt(string,radix)</span></p><p><span style="font-size: 12px;">radix: 2-binary 16 - hexadecymalnie 8 - oktalny 10 - dziesiątkowy</span>&nbsp;&nbsp;&nbsp;&nbsp;</p><p>string into array: <b>split()</b> np. string.split("")</p><p>array into string: join() np. array.join("") <b>może też przyjąć regex</b></p><p><span style="font-size: 18px;">﻿EXTERNAL CODE</span></p><p><span style="font-size: 12px;">﻿require</span></p><p><span style="font-size: 12px;"><b>import</b>: import { function } from "file_path_goes_here" ,&nbsp; <b>&nbsp;import *</b> as object_with_whatever_name from file_path</span></p><p><span style="font-size: 12px;"><b>export</b>: export { exportowanaFunkcja } //// export exportowanaZmienna /// ew.&nbsp; export { exportowanaFunkcja, exportowanaZmienna }<br></span><span style="font-size: 12px;">﻿<b>export default:</b>&nbsp; &nbsp;export default variable -- używane jako fallback case&nbsp;</span><span style="font-size: 18px;"><br></span><span style="font-size: 12px;">import default: import add&nbsp; &nbsp;&lt;--- nie ma {}<br></span><span style="font-size: 18px;">﻿</span></p><p><span style="font-size: 18px;">REGEX</span></p><p><span style="font-size: 11px;">przykład:</span></p><p>&nbsp; &nbsp; let testStr = "theCode";</p><p>&nbsp;&nbsp;&nbsp;&nbsp;let testRegex = /Code/;</p><p>&nbsp; &nbsp; testRegex.test(testStr); //returns true</p><p>inny sposób na tworzenie regexów:</p><p>var re = new RegExp('wzór','flagi')</p><p><b>regex object&nbsp; = /key/</b>&nbsp; uwaga case sensitive&nbsp; &nbsp;&nbsp;<span style="font-size: 11px;">﻿</span><span style="font-size: 12px;">﻿</span><span style="font-size: 18px;"><br></span><span style="font-size: 12px;">szukanie<b> kilku</b> patternów /pierwszypattern|drugipattern/</span></p><p><span style="font-size: 12px;"><b>flagi</b>: i - ignore case, g-zwracanie wielu przypadków</span></p><p><span style="font-size: 12px;">użycie flag: /regex/flaga1flaga2</span></p><p><span style="font-size: 12px;"><b>metody:</b></span></p><ul><li><span style="font-size: 12px;">regex.test(string) - zwraca prawda/fałsz czy dany pattern znajduje sie w stringu</span></li><li><span style="font-size: 12px;">string.match(regex) - zwraca dany pattern ze stringa w tabeli</span></li><li><span style="font-size: 12px;">string.replace(regex, czym), przy pomocy drugiego argumentu można uzyskać dostęp do capture group używając $numer_grupy</span></li><li><span style="font-size: 12px;">string.search(regex)</span></li></ul><p><span style="font-size: 12px;"><b>symbole i znaczenia:</b></span></p><ul><li><span style="font-size: 12px;"><b>.</b> - oznacza każdy znak&nbsp;</span></li><li><span style="font-size: 12px;"><b>[]</b> - [literki,które można wstawić w dane miejsce żeby pasowało] np. /[nb]un/ matchuje bun i nun</span></li><li><span style="font-size: 12px;">"<b>-</b>" - "-" użyty w [] oznacza że obejmuje zbiór alfabetycznie od jednej literki do drugiej np. [a-e] obejmuje od a do e tak samo numerki [0-5]</span></li><li><span style="font-size: 12px;"><b>[^]&nbsp;</b>-<b> negacja</b> np. /[^aeiou]/ - wszystkie znaki które nie są w nawiasach kwadratowych</span></li><li><span style="font-size: 12px;"><b>+</b> - znak występuje <b>jeden lub więcej razy</b></span></li><li><span style="font-size: 12px;"><b>*</b> - znak występuje<b> zero lub więcej razy</b></span></li><li><span style="font-size: 12px;"><b>?</b>&nbsp;- również oznacza&nbsp;<b>zero lub jeden raz</b></span></li><li><span style="font-size: 12px;"><b>{min, max}</b>&nbsp;- znak występuje między min a max razy, jest też możliwe<b> {min,}</b> wtedy definiujemy tylko dolną granicę</span></li><li><span style="font-size: 12px;"><b>{konkretna_ilość_znaków}</b></span></li><li><span style="font-size: 12px;"><b>? po * lub +</b>&nbsp;- <b>lazy match</b> - matchuje najmniejszą pasującą część stringa np. "titanic" /t[a-z]*?i/ returns "ti" a normalnie było by /t[a-z]*i/ returns "titani"</span></li><li><span style="font-size: 12px;"><b>^</b> - pattern musi znajdować się na początku stringa np. [^a]&nbsp; matchuje a znajdujące się na początku stringa</span></li><li><span style="font-size: 12px;"><b>$</b> - pattern musi się znajdować na końcu stringa</span></li><li><span style="font-size: 12px;">jakby ^string$</span></li><li><span style="font-size: 12px;"><b>(?=...)</b> - positive<span style="background-color: rgb(255, 0, 0);"> lookahead</span> - matchuje poprzedniego stringa tylko jeśli po nim znajduje się match zamieszczony w ...</span></li><li><span style="font-size: 12px;"><b>(?!...) </b>- negative lookahead - matchuje poprzedniego stringa tylko jeśli po nim nie znajduje się match zamieszczony w ...</span></li><li><span style="font-size: 12px;"><b>() </b>- przy pomocy można wziąć całą grupę regexów i powtórzyć ją kilka razy np. /<b>(</b>w{3}\s<b>)+</b>/ &lt;--- w tym wypadku + dotyczy wszystkiego w nawiasie</span></li><li><span style="font-size: 12px;"><b>(grupa)\1</b> - \1 oznacza tą grupę jak komuś się nie chce pisać</span></li><li><span style="font-size: 12px;">(grupa1)<b>|</b>(grupa2) - zwyczajny <b>OR</b></span></li></ul><p><b>skróty:</b>&nbsp;</p><ul style="letter-spacing: 0.1px;"><li><span style="font-size: 12px;"><b>\w</b>&nbsp;- skrót dla [a-zA-Z0-9_] &lt;---- podkreślnik też matchuje</span></li><li><span style="font-size: 12px;"><b>\W&nbsp;</b>- skrót dla [^a-zA-Z0-9_]</span></li><li><span style="font-size: 12px;"><b>\d</b> - skrót dla [0-9] digits</span></li><li><span style="font-size: 12px;"><b>\D</b> - skrót dla [^0-9]</span></li><li><span style="font-size: 12px;"><b>\s</b> - skrót dla [\r\t\f\n\v] &lt;--- matchuje te różne <b>śmieszne stringowe symbole</b></span></li><li><span style="font-size: 12px;"><b>\S </b>- skrót dla&nbsp;</span>[^\r\t\f\n\v]</li></ul><p><span style="font-size: 18px;">﻿DEBUGGING</span></p><p><span style="font-size: 12px;">﻿<b>console.log()</b></span></p><p><span style="font-size: 12px;">console.clear()</span></p><p><span style="font-size: 12px;"><b>debugger &lt;--</b>&nbsp;zatrzymuje funkcję i robi call po debugger</span></p><p><span style="font-size: 12px;"><b>typeof</b> np. typeof "" //string typeof 6// number</span></p><p><span style="font-size: 12px;"><b>typy w JS</b>: Boolean, Null, Undefined, Number, String, Symbol, Object(arraye to w jsie obiekty technicznie rzecz biorąc)</span></p><p><span style="font-size: 12px;">wartości stanowiące fałsz w JS: "", false, 0, NaN, undefined, null</span></p><p><span style="font-size: 12px;"><b>common mistakes</b>:&nbsp;</span></p><ul><li><span style="font-size: 11px;">﻿</span><span style="font-size: 12px;">misspelled variable</span></li><li><span style="font-size: 12px;">unclosed parentheses</span></li><li><span style="font-size: 12px;">mixed usage of single and double quotes</span></li><li><span style="font-size: 12px;">= instead of == or ===</span></li><li><span style="font-size: 12px;">missing parentheses after function call</span></li><li><span style="font-size: 12px;">arguments passed in the wrong order</span></li><li><span style="font-size: 12px;"><b>off by one</b> in array index</span></li><li><span style="font-size: 12px;">infinite loop - no <b>terminal condition</b></span></li></ul><p><span style="font-size: 18px;">﻿KORESPONDENCJA JS Z HTML (DOM):</span></p><p><span style="font-size: 12px;">﻿położenie w html:</span></p><ul><li><span style="font-size: 12px;">wewnątrz &lt;script&gt; &lt;/script&gt; w head</span></li><li><span style="font-size: 12px;">wewnątrz &lt;script&gt; w body</span></li><li>w osobnym pliku <b>&lt;script src = "skrypt.js"&gt;&lt;/script&gt;</b></li></ul><p>pokazywanie danych:</p><ul><li>innerHTML</li><li>document.write();</li><li>window.alert();</li><li>console.log();</li></ul><p><span style="font-size: 12px;">﻿</span>&nbsp;metody:</p><ul><li><span style="font-size: 12px;">﻿document.<b>getElementById</b>();</span></li><li><span style="font-size: 12px;">document.<b>getElementsByTagName</b>();</span></li><li><span style="font-size: 12px;">document.<b>getElementsByClassName</b>();</span></li><li><span style="font-size: 12px;">document.<b>querySelectorAll(tag.class/ tag.id)</b></span></li><li><span style="font-size: 12px;"><b>this.innerHTML </b>&lt;--- można od razu wewnątrz eventu zmienić wartość danego obiektu</span></li><li><span style="font-size: 12px;">document.getElementById().<b>innerHTML</b> = "xyz"; &lt;-- zmiana contentu tego elementu</span></li><li><span style="font-size: 12px;">document.getElementById().<b>style</b>.positon = "relative" &lt;-- zmiana stylu elementu</span></li><li><span style="font-size: 12px;">document.getElementyById().<b>attribute</b> = 'new value'</span></li><li><span style="font-size: 12px;">document.<b>createElement('p')</b></span></li><li><span style="font-size: 12px;">document.<b>createTextNode('text'), paragraph.appendChild(TextNode)</b></span></li><li><span style="font-size: 12px;"><b>insertBefore(objecttoappend,objectbeforewhichappend)</b></span></li><li><span style="font-size: 12px;"><b>parent.removeChild(child)</b></span></li></ul><p><b>najpopularniejsze eventy </b>&lt;element event = "whattodo"&gt;:</p><ul><li><span style="font-size: 12px;">﻿onchange</span></li><li><span style="font-size: 12px;">onclick</span></li><li><span style="font-size: 12px;">onmouseover</span></li><li><span style="font-size: 12px;">onmouseout</span></li><li><span style="font-size: 12px;">onkeydown</span></li><li><span style="font-size: 12px;">onload</span></li></ul><p><b>w funkcji wywołanej przez event, this odnosi się do obiektu, który wywołał ten event</b></p><p><b>dodawanie event handlerów</b>: document.getElementById('id')<b>.onclick</b> = funkcja();</p><p><b>szukanie wewnątrz obiektu</b>: document.getElementById('id').getElementsByTagName('tagname');</p><p><b>dodawanie event listenerów</b>: document.getElementById('id').addEventListener('click',function,useCapture = true/false) &lt;--- tym się różni od zwyczajnego onclick, że nie usuwa pozostałych event listenerów</p><p><span style="font-size: 18px;">﻿KORESPONDENCJA JS Z PRZEGLĄDARKĄ (BOM)</span></p><ul><li><span style="font-size: 12px;">﻿window.innerHeight window.innerWidth</span></li><li><span style="font-size: 12px;">window.open() window.close()</span></li><li><span style="font-size: 12px;">window.moveTo() window.resizeTo()</span></li></ul><p><span style="font-size: 12px;"><b>window.screen</b> czy po prostu screen oferuje informacje o ekranie użytkownika</span></p><ul><li><span style="font-size: 12px;">screen.width screen height</span></li><li><span style="font-size: 12px;">screen.<b>availWidth</b> availHeight &lt;--- width i height minus wszystkie taskbary itp</span></li></ul><p><b>window.location&nbsp;</b>daje dostęp do paska url</p><ul><li>window.location.<b>href</b> &lt;--- daje URL obecnej strony</li><li>window.location.<b>hostname</b> &lt;--- daje nazwę hosta</li><li>window.location.<b>pathname</b> &lt;--- daje ścieżkę obecnej strony</li><li>window.location.<b>assign</b> &lt;--- otwiera nowy dokument</li><li>window.location.<b>protocol</b> &lt;--- daje protokół strony</li><li>por<b>t</b></li></ul><p><b>window.history &lt;-- dostęp do historii przeglądania</b></p><ul><li><b>history.back()</b>&lt;--- przzejście do poprzednio odwiedzana strona</li><li><b>history.forward()</b>&lt;-- przejście do następnie odwiedzana strona</li></ul><p><b>window.navigator</b> &lt;-- info o przeglądarce użytkownika i systemie</p><ul><li><span style="letter-spacing: 0.1px;">navigator.<b>appName</b></span></li><li><span style="letter-spacing: 0.1px;">navigator.<b>appCodeName</b></span></li><li><span style="letter-spacing: 0.1px;">navigator.platform&nbsp;</span></li><li><span style="letter-spacing: 0.1px;">language&nbsp;</span></li><li>product</li><li><span style="letter-spacing: 0.1px;">appVersion</span></li><li><span style="letter-spacing: 0.1px;">userAgent</span></li></ul><p><b>popupy:</b></p><ul><li>window.alert()</li><li>window.confirm() jezeli ok to return true else return false</li><li>window.prompt('some text','default text') <b>zwraca user input</b></li></ul><p><b>funkcje asynchroniczne</b></p><ul><li>setInterval(funkcja,milisekundy) &lt;--- POWTARZA</li><li>setTimeout(funkcja,milisekundy) &lt;--- NIE POWTARZA</li><li>clearTimeout(nazwa zmiennej timeoutowej)</li><li>clearInterval(nazwa zmiennej intervalowej)</li></ul><p><b>cookies</b></p><ul><li>document.cookie = 'wartość ciasteczka'</li><li>username = ;</li><li>expires = data;</li><li>var cookie = document.cookie &lt;-- cała zawartość cookie w var cookie<br></li></ul><p><br></p><p><b>WNĘTRZE INPUTA ELEMENT.VALUE</b></p><p><span style="font-size: 18px;">﻿DATY:</span></p><p><span style="font-size: 12px;">constructory:</span></p><ul><li><span style="font-size: 12px;"><b>﻿new Date() </b>&lt;--- nowy object z obecnym czasem, statycznym ustawionym w momencie stworzenia obiektu</span></li><li><span style="font-size: 12px;">new Date(year,month,day,hours,minutes,seconds,miliseconds)</span></li><li><span style="font-size: 12px;">new Date(miliseconds) &lt;-- miliseconds after january 1 1970</span></li></ul><p><b>w javascripcie styczeń jest 0 miesiącem</b></p><p><b>compare dates - wcześniejsza &lt; póżniejsza // returns true</b></p><p><span style="font-size: 18px;">﻿EVENT BUBBLING:</span></p><p><span style="font-size: 11px;">﻿</span><span style="font-size: 12px;">﻿&lt;div onclick = "funkcja()"&gt; &lt;em&gt;&lt;/em&gt;&lt;/div&gt; &lt; --- tyczy się również obiektów należących do niego</span></p><p><span style="font-size: 12px;">kliknięcie w taki element p &lt;div onclick = 'funkcja2'&gt;&lt;p onclick = 'funkcja1'&gt;&lt;/p&gt;&lt;/div&gt; spowoduje najpierw wywołanie funkcji 1 a potem 2&nbsp;</span></p><p><span style="font-size: 12px;">jednak element kliknięty możemy uzyskać przy pomocy <b>event.target.tagName</b>, a element, którego własnością jest element kliknięty <b>this.tagName</b><br></span><b>event.stopPropagation() &lt;--- zatrzymuje bubbling a taki hardkorowy event.stopImmediatePropagation()</b></p><p><span style="font-size: 18px;">﻿CANVAS</span><span style="font-size: 12px;">﻿</span></p><p><span style="font-size: 12px;">&lt;<b>canvas id = x width = y height =z style = t</b>&gt;&lt;/canvas&gt;</span></p><p><span style="font-size: 12px;">document.getElementById('x').<b>getContext('2d')</b></span></p><p><span style="font-size: 12px;"><b>ctx.beginPath()</b></span></p><p><span style="font-size: 12px;"><b>ctx.stroke()</b></span></p><p><span style="font-size: 12px;"><b>metody:</b></span></p><ul><li>moveTo(x,y)</li><li>lineTo(x,y)</li><li>fillRect(x,y,width,height)</li><li>arc(x,y,r,startingangle,endingangle)</li><li>drawImage(image,x,y)</li></ul><p><b>style:</b></p><ul><li>fillStyle</li><li>strokeStyle</li></ul><p>text:</p><ul><li>font(fontname)</li><li>fillText(text,x,y)</li><li>strokeText(text,x,y)</li></ul><p><b><br></b></p><p><span style="font-size: 18px;">﻿FORMULARZE</span></p><p><span style="font-size: 12px;"><b>﻿onsubmit = 'return validateForm()'</b></span></p><p><span style="font-size: 12px;"><b>document.forms['formname']['elementoftheform'].value&nbsp;</b></span></p><p><span style="font-size: 12px;"><b>ATRYBUTY HTML DO WALIDACJI:</b></span></p><ul><li><span style="font-size: 12px;">max</span></li><li><span style="font-size: 12px;">min&nbsp;</span></li><li><span style="font-size: 12px;">pattern</span></li><li><span style="font-size: 12px;">required</span></li></ul><p><b>FUNKCJE JS DO WALIDACJI:</b></p><ul><li>checkValidity() &lt;-- sprawdza poprawność wartości elementu na podstawie atrybutów html&nbsp;</li><li>setCustomValidity() &lt;-- ustawienie własnej validation message</li></ul><p><b>ATRYBUTY JS DO WALIDACJI:</b></p><ul><li>element.validity; &lt;--- zawiera rózne errory&nbsp;</li></ul><ul><li>element.validationMessage;</li></ul><p><b>element.validity:</b></p><ul><li>range overflow</li></ul><p><span style="font-size: 18px;">AJAX</span></p><p><span style="font-size: 12px;">﻿Kluczem ajaxa jest obiekt XMLHttpRequest</span></p><p><span style="font-size: 12px;">var xhttp = new XMLHttpRequest();</span></p><p><span style="font-size: 12px;">podstawy:</span></p><ul><li><span style="font-size: 12px;">aby wysłać request do serwera stosujemy: open() i send()&nbsp; &nbsp; &nbsp;xhttp.open('metoda np. GET albo POST','plik który chcemy wydobyć',asynchroniczne:true/nieascynchroniczne:fałsz); xhttp.send()</span></li><li><span style="font-size: 12px;">aby wysyłać pliki takie jak formularz html trzeba dodać label z którym wyślemy plik do serwera <b>xhttp.open('POST', 'gdzie_wyslac',true)</b>;&nbsp;<b>xhttp.setRequestHeader('Content-type','application/x-www-form-urlencoded'); xhttp.send('fname=Henry&amp;lname=Ford')</b></span></li><li><span style="font-size: 12px;"><b>aby wysylać GETEM: </b>xhttp.open('GET','<b>adres?fname=Henry&amp;lname=Ford</b>',true); xhttp.send()&nbsp;</span></li><li><span style="font-size: 12px;"><b>xhttp.onreadystatechange &lt;--- funkcja którą wykonać po otrzymaniu informacji zwrotnej, można ją definiować np. </b>xhttp.onreadystatechange = function(){console.log(this.responseText)};</span></li><li><span style="font-size: 12px;">xhttp.readyState &lt;--- stan porozumiewania się z serwerem <b>0 - nie ma połączenia jeszcze 1 - połączenie nawiązane 2 - odpowiedź otrzymana 3 - request jest processingowany 4 - request gotowy&nbsp;</b></span></li><li><span style="font-size: 12px;">xhttp.status &lt;--- <b>200: "OK" 403:"Forbidden" 404:"Page not found" itd.</b></span></li><li><span style="font-size: 12px;">xhttp.responseText</span></li><li><span style="font-size: 12px;">xhttp.responseXML</span></li><li><span style="font-size: 12px;">xhttp.getAllResponseHeaders()</span></li><li><span style="font-size: 12px;">xhttp.getResponseHeader()<br><br></span><span style="font-size: 18px;"><br></span></li></ul><p><span style="font-size: 18px;">﻿JSON</span></p><p><span style="font-size: 12px;">﻿ssyntax: {<b>"wszystkowstringupodwójnym"</b>:"value","drugielement":"itsvalue","tablica":[]}</span></p><p><span style="font-size: 12px;"><b>plik JSON jest tekstem '{"name":"Tim","age":32,"married":true,"friends":["Piotr","Scott","Dmitry"]}'</b></span></p><p><b>niedozwolone</b> typy danych w json:</p><ul><li>funkcja</li><li>data</li><li>undefined</li></ul><p><b>dozwolone</b> i zapis:</p><ul><li>values in json can be array {"ioa": ["Tim","Tom","Tam" ]}</li><li>values in json can be object {"employees":{"engineer": "Josh", "designer": "Schlong"}}</li><li>values in json can be number {"age": 7}</li><li>values in json can be booleans {"married": true}</li><li>values in json can be null {"location": null}</li><li>values in json can be string, but <b>""</b> not <b>''&nbsp;</b>&nbsp;&nbsp;&nbsp;&nbsp;</li></ul><p><b>funkcje</b>:</p><ul><li>JSON.parse(JSONFILE,reviver(key,value)) &lt;-- tworzy z pliku JSON nowy obiekt, reviver to funkcja która bierze jako arrgument kazdy element danego jsona i sprawdza jego wartość, można dzięki temu coś pozmieniać, a potem go dodaje do obiektu</li><li>obj.stringify &lt;--- tworzy z obiektu string JSON</li></ul><p><span style="font-size: 18px;">D3</span></p><p><span style="font-size: 12px;"><b>instalacja</b>: ﻿&lt;script src="https://d3js.org/d3.v5.min.js"&gt;&lt;/script&gt;</span></p><p><span style="font-size: 12px;"><br></span><span style="font-size: 18px;"><br></span></p><p><br></p><p><span style="font-size: 18px;"><br></span><b><br></b></p><p></p><p></p>